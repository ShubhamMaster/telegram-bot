import os
import json
import random
import re
from telethon import TelegramClient, events
import google.generativeai as genai

# Load API credentials from environment variables
API_ID = int(os.getenv("API_ID"))
API_HASH = os.getenv("API_HASH")
BOT_TOKEN = os.getenv("BOT_TOKEN")
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")

# Initialize Google Gemini AI
genai.configure(api_key=GEMINI_API_KEY)
MODEL_NAME = "gemini-1.5-pro"
model = genai.GenerativeModel(MODEL_NAME)

# Load responses & bad words from JSON files
with open("responses.json", "r", encoding="utf-8") as file:
    response_data = json.load(file)

with open("badwords.json", "r", encoding="utf-8") as file:
    badword_data = json.load(file)

# Function to check if any 4-character sequence in message matches a bad word
def detect_badword_level(user_message):
    user_message = user_message.lower()
    
    for level in ["high", "medium", "low"]:
        for badword in badword_data[level]:
            badword = badword.lower()
            for i in range(len(badword) - 3):  # Check 4-char sequences
                if badword[i:i+4] in user_message:
                    return level  # Return the matched level
    
    return None  # No bad word found

# Words & phrases to replace AI/Gemini credits
CREDIT_WORDS = {
    r"\bGoogle\b": "KKN",
    r"\bAI\b": "KKN",
    r"\bArtificial Intelligence\b": "KKN",
    r"\bGemini\b": "KKN",
    r"\bGemini AI\b": "KKN",
    r"\bMachine Learning\b": "KKN",
    r"\bDeveloped by Google\b": "Created by KKN",
    r"\bPowered by AI\b": "Powered by KKN",
    r"\bAI-generated\b": "KKN-generated",
    r"\bThis response is generated by\b": "This response is from KKN",
    r"\bI am an AI\b": "I am KKN",
    r"\bI am a chatbot\b": "I am KKN",
    r"\bThis is an AI-generated response\b": "This is a KKN-generated response",
}

# Function to save conversation history in a single JSON file
def save_conversation(user_id, user_name, message, response):
filename = os.path.join(os.path.dirname(__file__), "chat_history.json")
    
    try:
        if os.path.exists(filename):
            with open(filename, "r", encoding="utf-8") as file:
                chat_data = json.load(file)
        else:
            chat_data = {}
    except:
        chat_data = {}
    
    user_key = user_name or str(user_id)
    if user_key not in chat_data:
        chat_data[user_key] = []
    
    chat_data[user_key].append({"message": message, "response": response})
    
    with open(filename, "w", encoding="utf-8") as file:
        json.dump(chat_data, file, indent=4, ensure_ascii=False)

# Initialize Telegram Bot
bot = TelegramClient('bot_session', API_ID, API_HASH).start(bot_token=BOT_TOKEN)

@bot.on(events.NewMessage)
async def handle_message(event):
    user_message = event.text.lower()
    user_id = event.sender_id
    user_name = (await event.get_sender()).username or str(user_id)

    # Check for bad words and get severity level
    badword_level = detect_badword_level(user_message)

    if badword_level:
        reply_text = random.choice(response_data[badword_level])
    else:
        try:
            response = model.generate_content(user_message)
            if response and response.candidates:
                reply_text = response.candidates[0].content.parts[0].text
            else:
                reply_text = random.choice(response_data["neutral"])
        except Exception as e:
            reply_text = f"Error: {e}"

    # Replace AI-related credits with "KKN"
    for pattern, replacement in CREDIT_WORDS.items():
        reply_text = re.sub(pattern, replacement, reply_text, flags=re.IGNORECASE)

    # Save conversation
    save_conversation(user_id, user_name, event.text, reply_text)
    
    await event.respond(reply_text)

# Start the bot
print("Bot is running...")
bot.run_until_disconnected()
